/* i2c - Simple example

   Simple I2C example that shows how to initialize I2C
   as well as reading and writing from and to registers for a sensor connected over I2C.

   The sensor used in this example is a MPU9250 inertial measurement unit.

   For other examples please check:
   https://github.com/espressif/esp-idf/tree/master/examples

   See README.md file to get detailed usage of this example.

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/

#include "esp_log.h"
#include "driver/i2c.h"
#include "i2c-lcd.h"
#include <stdio.h>
#include "driver/ledc.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/adc.h"
#include "driver/gpio.h"

static const char *TAG = "i2c-simple-example";

char buffer[10];
float num = 12.34;

/**
 * @brief i2c master initialization
 */
static esp_err_t i2c_master_init(void)
{
    int i2c_master_port = I2C_NUM_0;

    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = GPIO_NUM_21,
        .scl_io_num = GPIO_NUM_22,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = 100000,
    };

    i2c_param_config(i2c_master_port, &conf);

    return i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0);
}






#define LEDC_TIMER              LEDC_TIMER_0
#define LEDC_MODE               LEDC_LOW_SPEED_MODE
#define LEDC_OUTPUT_IO          5 // Define the output GPIO
#define LEDC_CHANNEL            LEDC_CHANNEL_0
#define LEDC_DUTY_RES           LEDC_TIMER_13_BIT // Set duty resolution to 13 bits
#define LEDC_DUTY               4096 // Set duty to 50%. (2 ** 13) * 50% = 4096
#define LEDC_FREQUENCY          4000 // Frequency in Hertz. Set frequency at 4 kHz

#define V0 1000
#define V1 2000
#define V2 3000
#define V3 4000


#define LED_PIN_1 27
#define LED_PIN_2 26
#define LED_PIN_3 33
#define LED_PIN_4 32



uint32_t voltage;

void pwm_init(void)
{
    // Prepare and then apply the LEDC PWM timer configuration
    ledc_timer_config_t ledc_timer =  {
        .speed_mode       = LEDC_MODE,
        .timer_num        = LEDC_TIMER,
        .duty_resolution  = LEDC_DUTY_RES,
        .freq_hz          = 1000,
        .clk_cfg          = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));

    // Prepare and then apply the LEDC PWM channel configuration
    ledc_channel_config_t ledc_channel =  {
        .speed_mode     = LEDC_MODE,
        .channel        = LEDC_CHANNEL,
        .timer_sel      = LEDC_TIMER,
        .intr_type      = LEDC_INTR_DISABLE,
        .gpio_num       = LEDC_OUTPUT_IO,
        .duty           = 0, // Set duty to 0%
        .hpoint         = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));
}

static void stop_pwm_temporarily()
{
    
    ESP_ERROR_CHECK(ledc_stop(LEDC_MODE, LEDC_CHANNEL, 1));
      
}

void update_duty(unsigned int freq, unsigned int uduty){

    gpio_set_pull_mode(LEDC_OUTPUT_IO,GPIO_PULLUP_DISABLE);
    
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_MODE, LEDC_CHANNEL));
    ledc_timer_config_t ledc_timer =  {
        .speed_mode       = LEDC_MODE,
        .timer_num        = LEDC_TIMER,
        .duty_resolution  = LEDC_DUTY_RES,
        .freq_hz          = freq,
        .clk_cfg          = LEDC_AUTO_CLK
    };

    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));
    ledc_channel_config_t ledc_channel =  {
        .speed_mode     = LEDC_MODE,
        .channel        = LEDC_CHANNEL,
        .timer_sel      = LEDC_TIMER,
        .intr_type      = LEDC_INTR_DISABLE,
        .gpio_num       = LEDC_OUTPUT_IO,
        .duty           = uduty,
        .hpoint         = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_MODE, LEDC_CHANNEL));

}

/*#######################################################################################*/
/*#######################################################################################*/
/*#######################################################################################*/
/*#######################################################################################*/


enum etat{Ready_To_Connect,Vehicle_Connected,Started_Charging,Stopped_Charging};
void transition();
enum etat pin_to_etat();

enum etat etat_actuel;
bool start;
void configure_voltage_reader(){

    // Configure ADC1 capture width
    // 12 bit decimal value from 0 to 4095
    adc1_config_width(ADC_WIDTH_BIT_12);
    //ADC1_CHANNEL_6 = pin 34),  attenuation (ADC_ATTEN_DB_11)
    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11);
    // pin 33
    adc2_config_channel_atten(ADC2_CHANNEL_8, ADC_ATTEN_DB_11);
    adc_vref_to_gpio(ADC_UNIT_2,ADC2_CHANNEL_8);
        // Take an ADC1 reading on a single channel (ADC1_CHANNEL_6 pin 34)
        // 11dB attenuation (ADC_ATTEN_DB_11) gives full-scale voltage 0 - 3.9V
        // 4053 ~ 3.86V
}

void configure_LED(){

    gpio_set_direction(LED_PIN_1, GPIO_MODE_OUTPUT);
    gpio_set_direction(LED_PIN_2, GPIO_MODE_OUTPUT);
    gpio_set_direction(LED_PIN_3, GPIO_MODE_OUTPUT);
    gpio_set_direction(LED_PIN_4, GPIO_MODE_OUTPUT);
    

}



void read_voltage(){
    for(;;){
        voltage = adc1_get_raw(ADC1_CHANNEL_6);
        printf("%ld\n", voltage);
        vTaskDelay(500 / portTICK_PERIOD_MS);
        transition();
    }
}

enum etat voltage_to_etat(){
    if( (0 <= voltage) && (voltage < V0) ){
        return Ready_To_Connect;
    }
    else if (voltage < V1){
        return Vehicle_Connected;
    }
    else if(voltage < V2){
        return Started_Charging;
    }
    else if(voltage < V3){
        return Stopped_Charging;
    }
    return Ready_To_Connect;
}

void display( enum etat e){

    lcd_clear();
    lcd_put_cur(0,0);
    
    switch(e){
        case Ready_To_Connect: 
            lcd_send_string("Connect the Car... ");
            break;
        
        case Vehicle_Connected:
            lcd_send_string("Vehicle detected !");
            lcd_put_cur(1,0);
            lcd_send_string("Processing ...");

            printf("Vehicle detected \n");
            break;
        
        case Started_Charging:
            lcd_send_string("Charging...");
            printf("Charging \n");
            break;

        case Stopped_Charging:
            lcd_send_string("Charging Stopped");
            lcd_put_cur(1,0);
            lcd_send_string("Enjoy the ride !");
            printf("Charging stopped \n");
            break;
    }
}


void transition(){
    if(start){
        enum etat signal = voltage_to_etat();
        if( signal == Ready_To_Connect || signal == etat_actuel || etat_actuel == (signal-1) )
        {
            switch(signal){

                case Ready_To_Connect:
                    //gpio_set_level(LED_PIN_1,1);
                    //gpio_set_level(LED_PIN_2,0);
                    //gpio_set_level(LED_PIN_3,0);
                    //gpio_set_level(LED_PIN_4,0);
                    etat_actuel=Ready_To_Connect;
                    display(Ready_To_Connect);
                    stop_pwm_temporarily();
                    //courrant_continue();
                    break;

                case Vehicle_Connected:
                    //gpio_set_level(LED_PIN_1,1);
                    //gpio_set_level(LED_PIN_2,1);
                    //gpio_set_level(LED_PIN_3,0);
                    //gpio_set_level(LED_PIN_4,0);
                    
                    etat_actuel = Vehicle_Connected;
                    gpio_set_level(LEDC_OUTPUT_IO,0);
                    update_duty(1000,4096);
                    display(Vehicle_Connected);
                    break;

                case Started_Charging:
                    //gpio_set_level(LED_PIN_1,1);
                    //gpio_set_level(LED_PIN_2,1);
                    //gpio_set_level(LED_PIN_3,1);
                    //gpio_set_level(LED_PIN_4,0);
                    etat_actuel = Started_Charging;
                    display(Started_Charging);
                    break;

                case Stopped_Charging:
                    //gpio_set_level(LED_PIN_1,1);
                    //gpio_set_level(LED_PIN_2,1);
                    //gpio_set_level(LED_PIN_3,1);
                    //gpio_set_level(LED_PIN_4,1);
                    etat_actuel = Stopped_Charging;
                    display(Stopped_Charging);
                    break;

            }
        }

        else{
            lcd_clear();
            lcd_send_string("Error!!!");
            lcd_put_cur(1,0);
            lcd_send_string("Connect the Car");
            gpio_set_level(LED_PIN_1,1);
            gpio_set_level(LED_PIN_2,0);
            gpio_set_level(LED_PIN_3,0);
            gpio_set_level(LED_PIN_4,1);
            etat_actuel=Ready_To_Connect;
        }
    }

}




void app_main(void)
{
    ESP_ERROR_CHECK(i2c_master_init());
    ESP_LOGI(TAG, "I2C initialized successfully");

    start = 1;
    etat_actuel = Ready_To_Connect;
    lcd_init();
    lcd_clear();
    configure_voltage_reader();
    configure_LED();
    xTaskCreatePinnedToCore(read_voltage,"voltage",2048,NULL,2,NULL,1);

    pwm_init();
    // Set duty to 50%
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_MODE, LEDC_CHANNEL, LEDC_DUTY));
    // Update duty to apply the new value
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_MODE, LEDC_CHANNEL));

}
